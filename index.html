<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - convex geometry</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
</head>

<body>


    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.module.js",
                    "three/addons/": "./jsm/"
                }
            }
        </script>

    <script type="module">

        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        

        let group, camera, scene, renderer;
        let pointsGeometry;
        let points;
        const vertices = [];
        let shapeGroup = new THREE.Group();
        init();
        animate();




        function init() {

            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0xF2F2F2);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // camera

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(15, 20, 30);
            scene.add(camera);

            // controls

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 10;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;

            // ambient PointLight

          //  scene.add(new THREE.AmbientLight(0x222222));

            // point light

            const light = new THREE.PointLight(0x33ffff, 1);
            //camera.add(light);

            // helper

            scene.add(new THREE.AxesHelper(20));

            const helixShapes = ['assets/triangle.png', 'assets/diamond.png', 'assets/circle.png', 'assets/hexagon.png',]
            // textures

            const loader = new THREE.TextureLoader();
            const texture = loader.load(helixShapes[Math.floor(Math.random() * helixShapes.length)]);
            //texture.colorSpace = THREE.SRGBColorSpace;
            console.log(texture)
            group = new THREE.Group();
            scene.add(group);



            // points

            let sphereGeometry = new THREE.SphereGeometry(10, 12, 6);


            // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data

            sphereGeometry.deleteAttribute('normal');
            sphereGeometry.deleteAttribute('uv');

            sphereGeometry = BufferGeometryUtils.mergeVertices(sphereGeometry);

            
            const positionAttribute = sphereGeometry.getAttribute('position');

            for (let i = 0; i < positionAttribute.count; i++) {

                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positionAttribute, i);
                vertices.push(vertex);

            }

            const pointsMaterial = new THREE.PointsMaterial({
                // color: 0xFF3333,
                map: texture,
                size: 10,
                alphaTest: .1
            });

             pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices);

            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            group.add(points);

            // convex hull

            const meshMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                opacity:1,
                wireframeLinewidth : 3,
                side: THREE.DoubleSide,
                transparent: true,
                wireframe: true,
               
            });

            const meshGeometry = new ConvexGeometry(vertices);

            const mesh = new THREE.Mesh(meshGeometry, meshMaterial);
            //group.add(mesh);




            var hullGeometry = new ConvexGeometry(points);
            //Build model
            //hullMesh = createMesh(hullGeometry);
            //console.log(hullMesh);
            mesh.material.color.setHex(0xD8E1E5)
            //Add to scene
            scene.add(mesh);




            //

            window.addEventListener('resize', onWindowResize);


            

        }


    function createMesh(geom) {
        console.log('createMesh')
        // Instantiate a green, translucent material
        var meshMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4422,
            transparent: true,
            opacity: 0,
        });
        meshMaterial.side = THREE.DoubleSide; //Set the material to be visible on both sides
        var wireFrameMat = new THREE.MeshBasicMaterial();
        wireFrameMat.wireframe = true; //Render materials as wireframes
        wireFrameMat.color = new THREE.Color(0x373837);
        // Assign both materials to geometry
        
       // var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [ meshMaterial, wireFrameMat,]);
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, meshMaterial);

        return mesh;

    }



        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

           // console.log(pointsGeometry)

            var materialPink = new THREE.MeshBasicMaterial({
                color: 0xF45B83,
                transparent: false,
                opacity: 1,
            });

            var materialYellow = new THREE.MeshBasicMaterial({
                color: 0xF8BE08,
                transparent: false,
                opacity: 0.1,
            });

            var materialBlue = new THREE.MeshBasicMaterial({
                color: 0x3F4C77,
                transparent: false,
                opacity: 0.1,
            });

            var materialGreen = new THREE.MeshBasicMaterial({
                color: 0x7ABC71,
                transparent: false,
                opacity: 0.1,
            });

            const materials = [materialPink, materialYellow, materialBlue, materialGreen];

            
            var spGeom = new THREE.SphereGeometry(.5, 24, 12);
            var spMesh = new THREE.Mesh(spGeom, materials[0]);
            let verticeCount = 0;

            
            vertices.forEach(function (vertice) {
                const helixShapes = ['assets/triangle.png', 'assets/diamond.png', 'assets/circle.png', 'assets/hexagon.png',]
                // textures

                const loader = new THREE.TextureLoader();
                const texture = loader.load(helixShapes[Math.floor(Math.random() * helixShapes.length)]);
                //texture.colorSpace = THREE.SRGBColorSpace;

                group = new THREE.Group();
                group.position.copy(vertice);
             //   scene.add(group);
   
               // verticeCount++;

               // shapeGroup.add(triangle);
                shapeGroup.rotation.y += 0.005;
                group.add(shapeGroup);

                //  let camPos = camera.position;
                // camPos

                const now = Date.now() / 800;
                group.rotation.x = now * .2;
                group.rotation.y = now * -.2;
                group.rotation.z = now * .2;
                // scene.rotation.y = now * .2;
                // scene.position.y = Math.cos(now) * 3;
                scene.add(group);
                //Update controller
                // controls.update();
          
                render();

            });


 


            requestAnimationFrame(animate);

            group.rotation.y += 0.005;

            render();

        }

        function render() {

            renderer.render(scene, camera);

        }






    // function createMesh(geom) {
    //     console.log('createMesh')
    //     // Instantiate a green, translucent material
    //     var meshMaterial = new THREE.MeshBasicMaterial({
    //         color: 0xff4422,
    //         transparent: true,
    //         opacity: 1,
    //     });
    //     meshMaterial.side = THREE.DoubleSide; //Set the material to be visible on both sides
    //     var wireFrameMat = new THREE.MeshBasicMaterial();
    //     wireFrameMat.wireframe = true; //Render materials as wireframes
    //     wireFrameMat.color = new THREE.Color(0x373837);
    //     // Assign both materials to geometry
    //     var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
    //         meshMaterial,
    //         wireFrameMat,
    //     ]);


    //     return mesh;

    // }



    </script>

</body>

</html>